---
description: How do we make our classes general? How do we make them safe?
---

# 8. Template Classes + Const Correctness

## Template Classes

软件工程的基本定理: Any problem can be solved by adding enough layers of indirection.任何问题都可以通过添加足够多的间接层来解决。

模板类: 对多种类型进行参数化的类. 这个类由general types的成员变量组成



### 我们用过的Template Classes

* Vectors
  * vector\<int> numVec; vector\<string> strVec;
* Maps
  * map\<int, string> int2Str; map\<int, int> int2Int;
* Sets
  * set\<int> someNums; set\<Student> someStudents;



### Writing a template: Syntax

```cpp
// Example: Structs
template<typename First, typename Secone> struct Mypair {
    First first;
    Second second;
};
```

```cpp
// mypair.h
template<typename First, typename Second> class Mypair {
    public:
        First getFirst();
        Second getSecond();
        
        void setFirst(First f);
        void setSecond(Second f);
    private:
        First first;
        Second second;
};
```

{% hint style="info" %}
使用泛型类名作为占位符!
{% endhint %}

```cpp
// mypair.cpp
#include "mypair.h"

template<typename First, typename Second> // 必须显式声明模板参数!
First MyPair<First, Second>::getFirst() { // 注意namespace不只是MyPair
    return first;
}

template<typename First, typename Second>
First MyPair<First, Second>::getSecond() {
    return second;
}
```

{% hint style="danger" %}
编译器在编译模板定义本身时(比如你写了一个 template \<typename T> void myFunction(T x))，它并不会生成任何机器代码。它只是把这个“蓝图”记在心里。只有当它在代码中看到你实际使用了这个模板(比如 myFunction(5) 或 myFunction\<std::string>(str)), 它才会根据这个蓝图和具体的类型(int 或 std::string)来生成对应的函数代码。
{% endhint %}

* 传统方式: 对于普通的非模板函数/类, 我们通常这样做:
  * 头文件(.h/.hpp): 包含函数/类的声明
  * 源文件(.cpp): 包含函数/类的定义
  * 在需要使用这个函数的其他文件中, 我们#include “something.h”, 链接器会把所有.cpp文件生成的.o文件链接在一起, 找到完整定义
* 但对于模板, 如果采取这种方式会出现问题:
* `my_template.h`: `template <typename T> void myFunction(T x);` // 只有声明
* `my_template.cpp`: `template <typename T> void myFunction(T x) { /*...实现...*/ }` // 定义在这里
* `main.cpp`: `#include “my_template.h”` 然后 `myFunction(5);` // 在这里实例化&#x20;

编译 `my_template.cpp` 时，编译器看到了模板的完整定义，但因为没有实例化（没人调用 `myFunction` with a specific type），所以它**不会生成任何代码**。\
编译 `main.cpp` 时，编译器看到了 `myFunction(5)`，它想实例化 `myFunction<int>`。但它**找不到函数定义**（定义在另一个 `my_template.cpp` 文件里，而那个文件已经编译完了，且是空的）。结果就是**链接错误（Linker Error）**，提示“未定义的外部符号”。



解决方法:

* 将完整定义写在.h文件中
* 或者, 在.h文件末尾#include对应实现的.tpp文件

### Member Types

* 有时候, 我们需要一个依赖于我们模板类型的类型名称.
* 比如iterators

```cpp
std::vector<int> a = {1, 2};
std::vector<int>::iterator it = a.begin();
```

* iterator 是vector的一个成员类型/嵌套类型/member type

#### Syntax

```cpp
// vector.h
template<typename T> class vector {
    public:
    using iterator = T*;
    
    iterator begin();
}
```

```cpp
// vector.cpp
template<typename T>
typename vector<T>::iterator vector<T>::begin() {...}
```

#### 1. 模板声明 (`template <typename T>`)

* **作用**：告诉编译器接下来的定义是一个模板，`T` 是一个类型参数。
* **为什么需要**：因为 `vector` 是一个类模板，它的成员函数也必然是函数模板。这个声明确保函数定义与类模板使用相同的模板参数。

#### 2. 返回类型 (`typename vector<T>::iterator`)

这是最复杂也是最关键的部分。

* **`vector<T>::iterator`**：这表示我们要使用 `vector<T>` 这个类内部定义的 `iterator` 类型。
* **关键的 `typename`**：这个关键字在这里**必须**使用。

**为什么需要 `typename`？**

因为对于编译器来说，`vector<T>` 是一个**依赖类型**——它的定义依赖于模板参数 `T`。在编译器实例化这个模板（比如用 `int` 替换 `T`）_之前_，它无法确定 `vector<T>::iterator` 到底是什么。

它可能是一个类型（比如 `using iterator = T*;`），也可能是一个静态成员变量（比如 `static int iterator;`）。编译器默认会假设它是一个**值（变量）**，而不是一个**类型**。

`typename` 关键字的作用就是**明确地告诉编译器**：”`vector<T>::iterator` 是一个类型，而不是一个值“。

**如果没有 `typename`，编译器会报错**，因为它会试图将 `iterator` 解释为一个变量名，然后发现它无法作为函数的返回类型。



#### Aside: Type Aliases

* 在应用代码中可以使用 `using type_name = type`&#x20;
* 在类中定义时, 产生一个嵌套类型, 如`vector::iterator`   &#x20;
* 在应用代码(如main.cpp)中使用时, 会在当前scope中创建type的别名, 直到跳出当前scope



#### summary

* 使用嵌套类型, 保证用户有对重要类型的标准化的访问方法
* 嵌套类型, 需要给出namespace`vector<T>::iterator`&#x20;
* 在声明之后, 就可以直接使用这个别名
* 声明时使用**typename**限制, 原因见上



## Const Correctness

const: 关键字, 表明一个 **变量/函数/参数** 不能被修改

```cpp
// main.cpp
std::string stringify(const Student& s) {
    return s.getName() + " is " + std::to_string(s.getAge()) + " years old.";
}
```

{% hint style="danger" %}
编译器必须明确的知道`getName` 和`getAge` 不会改变 `s` !

因此, 它们必须是const函数, 通过在函数签名末尾添加const实现.
{% endhint %}

```cpp
// student.h
class Student {
    public:
    ...
    std::string getName() const;
    int getAge() const;
    ...
};

// student.cpp
...
std::string Student::getName() const {
    return name;
}

int Student::getAge() const {
    return age;
}
...
```

* 所有const对象只能调用const函数



```cpp
// 非const版本
std::string& StrVector::at(size_t index) {
    if (index >= size()) {
        throw std::out_of_range("Index out of range in at.");
    }
    return operator[](index); // 调用 operator[] 获取元素引用
}

// const版本
const std::string& StrVector::at(size_t index) const {
    return static_cast<const std::string&>(const_cast<StrVector*>(this)->at(index));
}
```

* static\_cast\<new-type>(expression);
  * 用于强制类型转换
  * 如`int my_int = static_cast<int>(3.1);`&#x20;
  * 不能消除const
*   const\_cast\<new-type>(expression);

    * 用于去除const


* `const std::string&`: 返回一个常量字符串引用，调用者不能通过这个引用修改字符串内容
* `const` (在参数列表后): 表示这个成员函数不会修改类的任何成员变量

#### 1. `const_cast<StrVector*>(this)`

* `this` 指针在 const 成员函数中是 `const StrVector*` 类型
* `const_cast` 用于移除 `this` 指针的 const 属性，将其转换为 `StrVector*` 类型
* 这使得我们可以调用非 const 版本的 `at()` 函数

#### 2. `->at(index)`

* 使用转换后的非 const 指针调用非 const 版本的 `at()` 函数
* 这个调用会执行边界检查并返回一个非 const 引用

#### 3. `static_cast<const std::string&>(...)`

* 将非 const 版本返回的非 const 引用转换为 const 引用
* 这是必要的，因为 const 版本的函数必须返回 const 引用



```cpp
class StrVector
{
public:
    using iterator = std::string *;
    using const_iterator = const std::string *;
    /*...*/
    size_t size() const;
    bool empty() const;
    /*...*/
    void push_back(const std::string &elem);
    const std::string &at(size_t indx) iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
    /*...*/
}
```

## Summary

### Const and Const-correctness

* 多在代码中使用const修饰符
* 所有不改变成员变量的类函数都声明const
* 不要重复造轮子, 使用上述的小技巧重复使用轮子
* auto会自动去除const和&, 记得特别声明
* 对你的每一个容器类, 都去制作iterator与const\_iterator



### Template classes

* 在所有.h文件中的类定义前添加 `template<class T1, T2..>`&#x20;
* 在所有.cpp文件中的函数签名前添加`template<class T1, T2..>`&#x20;
* 函数return嵌套类型时, 签名要添加`typename` 修饰
* 记住模板的特性, 在初始化时才产生代码
