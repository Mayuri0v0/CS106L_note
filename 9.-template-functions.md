---
description: >-
  What else in C++ can be generalized? What is the philosophy behind
  generalization?
---

# 9. Template Functions

## Template Functions

> 我们能否编写一个作用于任意数据类型的函数?

模板函数: 可以作用于多于一个类型/类, 而不需要为每一个类型重载函数

```cpp
template<typename T=int> // T有默认类型int, 如果没有被规定, 默认为int
T myMin(T a, T b) {
    return a < b ? a : b;
}
```

{% hint style="success" %}
`template<typename T>` 与`template<class T>` 在功能上一致, 可以任意替换.
{% endhint %}

### Constraints and Concepts

在C++20提供的功能中, 我们可以在以下地方**规定可接受的类型**:

* 模板类
* 模板函数
* 模板类的非模板成员函数

这些规定/限制叫做 **constraints**.

一系列 constraints 的集合叫做 **concept**.

```cpp
template<typename T>
concept Addable = requires (T a, T b) {
    { a + b } -> std::same_as<T>;
};

// 以下两种方法是等价的
template<typename T> requires Addable<T>
T add(T a, T b) { return a + b; }

template<Addable T>
T add(T a, T b) { return a + b; }
```



### Calling template functions

我们可以显式地声明要传入的类型:

```cpp
std::cout << myMin<int>(3, 4) << std::endl;
```

我们也可以让编译器自行推断:

```cpp
template<typename T, typename U>
auto smarterMyMin(T a, U b) {
    return a < b ? a : b;
}

std::cout << smarterMyMin(3.2, 4) << std::endl;
```



### Behind the instantiation Scenes

和模板类一样, **模板函数在使用之前不会被编译**.

* 对于不同参数的每一次实例化, 编译器会单独生成一个特殊的版本.
* 在编译之后, 看起来就如同你为每一个类型重载了函数一样.



## Template metaprogramming

在实例化时才会生成实际的函数代码, 因此, 我们有一些用模板提高效率的方法.

* 一般来说, 代码在 **runtime** 时运行, 但使用模板元编程, 我们可以让代码在 **compile time** 时运行.

```cpp
template<unsigned n>
struct Factorial {
    enum { value = n * Factorial<n - 1>::value };
};

template<>
struct Factorial<0> {
    enum { value = 1 };
};

std::cout << Factorial<10>::value << std::endl;
```
