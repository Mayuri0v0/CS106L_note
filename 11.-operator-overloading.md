---
description: >-
  How can we repurpose common operators to write descirptive and functional
  code?
---

# 11. Operator Overloading

## Operators and Operator Overloading

* 就像在类中声明函数一样, 我们可以声明运算符功能
* 当我们在自己的对象上使用重载的运算符时, 就会产生我们重载的效果
* 就如同函数重载一样, 我们给予相同名字时, 它就会override操作符的行为

{% hint style="warning" %}
绝大部分操作符都可以被重载, **除了**:

* 作用域解析
  * `::`
* 三元运算符
  * `?`
* 成员访问
  * `.`
* 指针到成员
  * `.*`
* 对象大小, 类型, 类型转换
  * `sizeof()` `typeid()` `cast()`&#x20;
{% endhint %}



```cpp
// student.h
class Student {
    public:
    std::string getName() const;
    void setName(string name);
    int getAge() const;
    void setAge(int age);
    bool operator < (const Student& rhs) const; // 传入参数为右操作数
    
    private:
    std::string name;
    std::string state;
    int age;
};
```

```cpp
// student.cpp
#include "student.h"
bool operator < (const Student& rhs) const {
    return age < rhs.age;
}
```



我们可以用两种方法重载操作符:

* 成员函数
  * 在class内部声明重载的操作符
  * 允许你使用成员变量
* 非成员函数
  * 在任何class之外重载操作符
  * 将左操作数和右操作数都定义为参数



### Non-member overloading

STL更偏爱非成员重载.

* 这允许左操作数为non-class类型(比如比较 **double** 和 **Fraction**)
* 允许我们重载并非我们自己的类的操作符(如 **vector** 和 **StudentList**)

```cpp
bool operator < (const Student& lhs, const Student& rhs);
```

* STL通过运算符重载cout混合类型

```cpp
std::ostream& operator << (std::ostream& out, const Time& time) {
    out << time.hours << ":" << time.minutes << ":" << time.seconds;
    return out;
}
```

{% hint style="danger" %}
一些操作符, 比如`new` 和`delete` , 它们不需要一个特别类型.

当你在一个类之外重载这些操作符时, 这被称作 global overloading, 它会影响程序中的一切!

* `void* operator new(size_t size);`&#x20;
{% endhint %}



#### Rules and Philosophy

* 当你使用运算符重载时, 它的含义应当是显然的
* 功能应当与运算符的原本功能合理相关
* 当意义不明时, 请使用函数而不是运算符重载

> 成员函数重载能让我们访问到成员的私有变量, 对于非成员函数重载, 我们还能做到这些吗?



### Friend Function

`friend` 关键字允许 非成员函数/类 访问到其他类的私有信息.

* 在**类**或者**函数**的开头使用`friend` 关键字.

```cpp
// student.h
class Student {
    public:
    /* ... */
    friend bool operator < (const Student& lhs, const Student& rhs) const;
    
    private:
    /* ... */
};

bool operator < (const Student& lhs, const Student& rhs) {
    return lhs.age < rhs.age;
}
```

