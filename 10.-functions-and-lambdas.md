---
description: How can we make template functions even more general?
---

# 10. Functions and Lambdas

## Functions and Lambdas

先浏览这个函数:

```cpp
template<typename InputIt, typename Datatype>
int count_occurrences(InputIt begin, InputIt end, Datatype val) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (*iter == val) count++;
    }
    return count;
}

std::string str = "Xadia";
count_occurrences(str.begin(), str.end(), 'a');
```

它对任意的容器, 任意类型都能生效, 但只能查找一个单一目标.&#x20;

如果我们想要查找一个更 general 的类型呢? 比如元音字母.



### Predicate Functions

任何返回布尔值的函数叫做一个 **predicate**(断言)

* 我们需要各种各样的断言, 来替代上述代码中的`*iter == val` , 而且它们的参数数量也可能不同.

```cpp
template<typename InputIt, typename UniPred>
int count_occurrences(InputIt begin, InputIt end, UniPred pred) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (pred(*iter)) count++;
    }
    return count;
}

bool isVowel(char c) {
    std::string vowels = "aeiou";
    return vowels.find(c) != std::string::npos;
}
 
std::string str = "Xadia";
count_occurrences(str.begin(), str.end(), isVowel);
```

> `Unipred` 是什么类型?



### Function Pointers

UniPred 是一个 **函数指针** !

* 函数指针就如同其他指针一样
* 它们可以像变量一样作为参数传递, 或者作为模板的类型
* 它们可以像函数一样被调用

{% hint style="warning" %}
然而, 使用断言缺少泛化, 我们需要书写许多的断言函数.

能不能让函数知道我们的断言的更多信息呢?

但问题是, 我们只能为断言传递一个参数.

如何在不添加参数的情况下传递更多信息呢?
{% endhint %}



## Lambdas

Lambdas 是**内联的**, **匿名的**函数, 可以知道同一个scope中定义的函数的信息

