---
description: >-
  What else in C++ can be generalized? What is the philosophy behind
  generalization?
---

# 9. Template Functions

## Template Functions

> 我们能否编写一个作用于任意数据类型的函数?

模板函数: 可以作用于多于一个类型/类, 而不需要为每一个类型重载函数

```cpp
template<typename T=int> // T有默认类型int, 如果没有被规定, 默认为int
T myMin(T a, T b) {
    return a < b ? a : b;
}
```

{% hint style="success" %}
`template<typename T>` 与`template<class T>` 在功能上一致, 可以任意替换.
{% endhint %}

### Constraints and Concepts

在C++20提供的功能中, 我们可以在以下地方**规定可接受的类型**:

* 模板类
* 模板函数
* 模板类的非模板成员函数

这些规定/限制叫做 **constraints**.

一系列 constraints 的集合叫做 **concept**.

```cpp
template<typename T>
concept Addable = requires (T a, T b) {
    { a + b } -> std::same_as<T>;
};

// 以下两种方法是等价的
template<typename T> requires Addable<T>
T add(T a, T b) { return a + b; }

template<Addable T>
T add(T a, T b) { return a + b; }
```



### Calling template functions

我们可以显式地声明要传入的类型:

```cpp
std::cout << myMin<int>(3, 4) << std::endl;
```

我们也可以让编译器自行推断:

```cpp
template<typename T, typename U>
auto smarterMyMin(T a, U b) {
    return a < b ? a : b;
}

std::cout << smarterMyMin(3.2, 4) << std::endl;
```



### Behind the instantiation Scenes

和模板类一样, **模板函数在使用之前不会被编译**.

* 对于不同参数的每一次实例化, 编译器会单独生成一个特殊的版本.
* 在编译之后, 看起来就如同你为每一个类型重载了函数一样.



## Template metaprogramming

在实例化时才会生成实际的函数代码, 因此, 我们有一些用模板提高效率的方法.

* 一般来说, 代码在 **runtime** 时运行, 但使用模板元编程, 我们可以让代码在 **compile time** 时运行.

```cpp
template<unsigned n>
struct Factorial {
    enum { value = n * Factorial<n - 1>::value };
};

template<>
struct Factorial<0> {
    enum { value = 1 };
};

std::cout << Factorial<10>::value << std::endl;
```



### Aside: constexpr

也有一些其他的方法让代码在编译时运行.

`constexpr` 关键字声明了一个常量表达式.

* 常量表达式必须被立即初始化, 并且在编译时运行.
* 向常量表达式传递的参数必须也是 const/constant 表达式.

变量也可以声明为 `constexpr`&#x20;

```cpp
constexpr double fib(int n) {
    if (n == 1) return 1;
    return fib(n - 1) * n;
}

int main() {
    const long long bigval = fib(20);
    std::cout << bigval << std::endl;
}
```



### Why?

可以通过上述方法提升代码性能

* 编译后代码会更小
* 在编译时只运行一次, 在运行时可以被多次使用

{% hint style="warning" %}
模板元编程是一个 **accident**, 它是被 **发现** 的, 不是被 **发明** 的!
{% endhint %}



### Applications of TMP

模板元编程的使用不多, 但它有一些有趣的应用.

* 优化 矩阵/树/其他数学结构 的操作.
* Policy-based design(一种编程方法)
* 游戏图形



