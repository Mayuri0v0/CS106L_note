---
description: 所有容器都是在STL中定义好的类
---

# 7. Classes

## Class

类是程序员自定义的类型, 对对象或数据类型的抽象.



结构体的问题:

* 所有数据默认是public的
* 所有成员需要显式初始化



类为用户提供了**public**的接口, 并将其与**private**的实现隔离

```cpp
// student.h
class Student {
    public:
    std::string getName();
    void setName(std::string name);
    int getAge();
    void setAge(int age);
    
    private:
    std::string name;
    std::string state;
    int age;
};
```

Public部分:

* Student对象的用户都可以直接访问这里的所有东西.
* 为访问private成员变量定义了接口.

Private部分:

* 通常存储所有成员变量.
* 用户无法直接访问或修改私有部分.

```cpp
// student.cpp
#include student.h

std::string Student::getName() {
    return name;
}

void Student::setName(std::string name) {
    this->name = name;
}

int Student::getAge() {
    return age;
}

void Student::setAge(int age) {
    if (age >= 0) {
        this->age = age;
    }
    else error("Age cannot be negative.");
}
```

* namespace\_name::name 是对 namespace\_name 中的某个接口的实现.
* 在实现中可以访问到 namespace\_name 的私有变量.
* this是一个指针, 指向调用这个方法的实例.



### Constructors

* 定义了创建实例时如何初始化成员变量.
* 当你创建Student实例时自动被调用.

```cpp
// student.cpp
#include student.h

// 1.0
Student::Student() {
    age = 0;
    name = "";
    state = "";
}

// 2.0, 函数重载
Student::Student() {
    age = 0;
    name = "";
    state = "";
}
Student::Student(std::string name, int age, std::string state) {
    this->name = name;
    this->age = age;
    this->state = state;
}

// 3.0, 使用初始化列表
Student::Student() : name{""}, age{0}, state{""} {}
Student::Student(std::string name, int age, std::string state) :
    name{name}, age{age}, state{state} {}
```

```cpp
// main.cpp
#include student.h
int main() {
    Student sarah;
    sarah.setName("Sarah");
    sarah.setAge(21);
    sarah.setState("CA");
    std::cout << sarah.getName() << " is from " << sarah.getState() << std:: endl;
    
    Student haven("Haven", 21, "AR");
    std::cout << haven.getName() << " is from " << haven.getState() << std::endl;
}
```



### Array

* 数组是所有容器的基本组成.
* 不要在应用代码中使用数组, 向量是数组的STL接口.

```cpp
int *my_int_array = new int[10];

int one_ele = my_int_array[0];
```



### Memory Management

* 数组空间需要手动释放.
  * delete \[] my\_int\_array;



### Destructor

* 实例的删除通常由析构函数进行
* 定义: Class\_name::\~Class\_name()
* 不需要显式调用, 会在实例out of scope时自动被调用
* 在.h文件中声明, 在.cpp文件中实现

```cpp
// student.cpp
#include student.h
Student::~Student() {
    delete [] my_array;
}
```



## Template Classes(intro)

软件工程的基本定理: Any problem can be solved by adding enough layers of indirection.任何问题都可以通过添加足够多的间接层来解决。

模板类: 对多种类型进行参数化的类. 这个类由general types的成员变量组成



### 我们用过的Template Classes

* Vectors
  * vector\<int> numVec; vector\<string> strVec;
* Maps
  * map\<int, string> int2Str; map\<int, int> int2Int;
* Sets
  * set\<int> someNums; set\<Student> someStudents;



### Writing a template: Syntax

```cpp
// Example: Structs
template<typename First, typename Secone> struct Mypair {
    First first;
    Second second;
};
```

```cpp
// mypair.h
template<typename First, typename Second> class Mypair {
    public:
        First getFirst();
        Second getSecond();
        
        void setFirst(First f);
        void setSecond(Second f);
    private:
        First first;
        Second second;
};
```

{% hint style="info" %}
使用泛型类名作为占位符!
{% endhint %}

```cpp
// mypair.cpp
#include "mypair.h"

template<typename First, typename Second> // 必须显式声明模板参数!
First MyPair::getFirst() {
    return first;
}

template<typename First, typename Second> // 必须显式声明模板参数!
First MyPair::getSecond() {
    return second;
}
```

{% hint style="danger" %}
编译器在编译模板定义本身时(比如你写了一个 template \<typename T> void myFunction(T x))，它并不会生成任何机器代码。它只是把这个“蓝图”记在心里。只有当它在代码中看到你实际使用了这个模板(比如 myFunction(5) 或 myFunction\<std::string>(str)), 它才会根据这个蓝图和具体的类型(int 或 std::string)来生成对应的函数代码。
{% endhint %}

* 传统方式: 对于普通的非模板函数/类, 我们通常这样做:
  * 头文件(.h/.hpp): 包含函数/类的声明
  * 源文件(.cpp): 包含函数/类的定义
  * 在需要使用这个函数的其他文件中, 我们#include “something.h”, 链接器会把所有.cpp文件生成的.o文件链接在一起, 找到完整定义
* 但对于模板, 如果采取这种方式会出现问题:
* `my_template.h`: `template <typename T> void myFunction(T x);` // 只有声明
* `my_template.cpp`: `template <typename T> void myFunction(T x) { /*...实现...*/ }` // 定义在这里
* `main.cpp`: `#include “my_template.h”` 然后 `myFunction(5);` // 在这里实例化&#x20;

编译 `my_template.cpp` 时，编译器看到了模板的完整定义，但因为没有实例化（没人调用 `myFunction` with a specific type），所以它**不会生成任何代码**。\
编译 `main.cpp` 时，编译器看到了 `myFunction(5)`，它想实例化 `myFunction<int>`。但它**找不到函数定义**（定义在另一个 `my_template.cpp` 文件里，而那个文件已经编译完了，且是空的）。结果就是**链接错误（Linker Error）**，提示“未定义的外部符号”。
