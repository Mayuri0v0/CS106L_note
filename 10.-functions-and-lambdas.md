---
description: How can we make template functions even more general?
---

# 10. Functions and Lambdas

## Functions and Lambdas

先浏览这个函数:

```cpp
template<typename InputIt, typename Datatype>
int count_occurrences(InputIt begin, InputIt end, Datatype val) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (*iter == val) count++;
    }
    return count;
}

std::string str = "Xadia";
count_occurrences(str.begin(), str.end(), 'a');
```

它对任意的容器, 任意类型都能生效, 但只能查找一个单一目标.&#x20;

如果我们想要查找一个更 general 的类型呢? 比如元音字母.



### Predicate Functions

任何返回布尔值的函数叫做一个 **predicate**(断言)

* 我们需要各种各样的断言, 来替代上述代码中的`*iter == val` , 而且它们的参数数量也可能不同.

```cpp
template<typename InputIt, typename UniPred>
int count_occurrences(InputIt begin, InputIt end, UniPred pred) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (pred(*iter)) count++;
    }
    return count;
}

bool isVowel(char c) {
    std::string vowels = "aeiou";
    return vowels.find(c) != std::string::npos;
}
 
std::string str = "Xadia";
count_occurrences(str.begin(), str.end(), isVowel);
```

> `Unipred` 是什么类型?



### Function Pointers

UniPred 是一个 **函数指针** !

* 函数指针就如同其他指针一样
* 它们可以像变量一样作为参数传递, 或者作为模板的类型
* 它们可以像函数一样被调用, 如`result = ptr(3, 4)` .但是显式的解引用也可以, 如`result = (*ptr)(3, 4)`

{% hint style="success" %}
在 C++ 中, 函数名本身就代表它的地址.

传入`isVowel` 或者`&isVowel` 均可.
{% endhint %}

{% hint style="warning" %}
然而, 使用断言缺少泛化, 我们需要书写许多的断言函数.

能不能让函数知道我们的断言的更多信息呢?

但问题是, 我们只能为断言传递一个参数.

如何在不添加参数的情况下传递更多信息呢?
{% endhint %}



## Lambdas

Lambdas 是**内联的**, **匿名的**函数, 可以知道同一个scope中定义的函数的信息

```cpp
auto var = [capture-clause] (auto param) -> bool {}
```

**a. 捕获列表 (Capture Clause) `[ ]`**

这是 Lambda 表达式**最独特和最重要的部分**。它定义了 Lambda 函数体能够访问的**外部作用域**中的变量，以及访问的方式（值捕获还是引用捕获）。

* `[]`：**不捕获任何外部变量**。Lambda 体只能使用它的参数和局部变量。
* `[=]`：**以值拷贝的方式捕获所有外部变量**。在 Lambda 体内可以使用所有外部变量，但不能修改它们（除非使用 `mutable`）。
* `[&]`：**以引用的方式捕获所有外部变量**。在 Lambda 体内可以修改这些变量，并且修改会影响到外部。
* `[a, &b]`：**混合捕获**。捕获特定变量，`a` 以值方式捕获，`b` 以引用方式捕获。
* `[this]`：**捕获当前的 `this` 指针**。允许 Lambda 访问其所属类的成员变量和函数。
* `[=, &x]`：**默认以值方式捕获所有变量，但 `x` 以引用方式捕获**。

```cpp
int a = 1, b = 2, c = 3;

// 值捕获 a， 引用捕获 b， 不捕获 c
auto lambda = [a, &b] {
    std::cout << a << ", " << b << std::endl;
    // std::cout << c; // 错误！c 未被捕获，无法使用
};

lambda(); // 输出： 1, 2
b = 100;
lambda(); // 输出： 1, 100 （a 是初始值的拷贝，b 是引用，值变了）
```

**b. 参数列表 (Parameter List) `( )`**

和普通函数的参数列表一样。如果不需要参数，可以省略括号（在 C++ 中，如果捕获列表不为空，某些情况下甚至可以完全省略参数列表，但为了清晰，通常保留空括号 `()`）。

```cilkcpp
auto add = [](int x, int y) { return x + y; };
std::cout << add(5, 3); // 输出： 8
```

**c. 返回类型 (Return Type) `-> type`**

通常可以**省略**，编译器会根据函数体内的 `return` 语句自动推导返回类型。

只有在一些复杂情况下才需要显式指明，例如当函数体内有多个 `return` 语句且返回类型不同，或者你想强制转换返回类型时。

```cpp
// 自动推导为 int
auto add = [](int x, int y) { return x + y; };

// 显式指明返回 double
auto divide = [](int x, int y) -> double {
    if (y == 0) return 0.0;
    return static_cast<double>(x) / y;
};
```

**d. 函数体 (Body) `{ }`**

和普通函数的函数体一样，包含要执行的代码。

{% hint style="warning" %}
默认情况下，**以值方式捕获的变量在 Lambda 体内是只读的**（`const` 的）。如果你需要在 Lambda 内部修改这些值拷贝的变量，必须在参数列表后加上 `mutable` 关键字。

**注意：** 这修改的只是外部变量在 Lambda 内部的**副本**，并不会影响外部的原始变量。
{% endhint %}

```cpp
int count = 0;
// 没有 mutable，无法编译
// auto increment = [count] { count++; };

// 有 mutable，可以编译
auto increment = [count] () mutable {
    count++;
    std::cout << "Internal count: " << count << std::endl;
};

increment(); // 输出： Internal count: 1
increment(); // 输出： Internal count: 2
std::cout << "External count: " << count << std::endl; // 输出： External count: 0 （外部值未改变）
```

{% hint style="success" %}
为什么多次调用`increment` 时, 内部的`count` 值会保留?

当定义一个 Lambda 表达式时，编译器会将其转换成一个**匿名类（函数对象）**。这个类包含：

* 一个用于存储捕获变量的数据成员
  * 当使用值捕获 `[count]` 时，Lambda 对象会有一个名为 `count` 的成员变量
  * 这个成员变量使用外部 `count` 的值进行初始化（此处为0）
*   一个重载的 `operator()` 函数（即函数调用运算符）

    * 每次调用 `increment()` 实际上是在调用同一个函数对象的 `operator()`
    * 因此，操作的是同一个成员变量 `count`   &#x20;

    这事实上创建了一个**闭包**, 对每一次lambda函数调用.
{% endhint %}



我们使用Lambda解决了问题:

```cpp
#include <string>

template<typename InputIt, typename UniPred>
int count_occurrences(InputIt begin, InputIt end, UniPred pred) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (pred(*iter)) count++;
    }
    return count;
}

int main() {
    std::string str = "Xadia";
    count_occurrences(str.begin(), str.end(), [](char c) -> bool {
        return std::string("aeiou").find(c) != std::string::npos;
    });
}
```



## All together

STL中有一个非常重要的, 标准函数对象:

`std::function<return_type(param_types)> func;`&#x20;

所有lambda, 仿函数, 函数指针, 都能够转换为标准函数.

但标准函数的开销**远远大于**函数指针和lambda.



### Virtual Functions

在使用与类函数相关的指针时要小心, 特别是存在子类时.

```cpp
class Animal {
...
    void speak() {
        std::cout << "I'm an animal" << std::endl;
    }
...
}

class Dog : public Animal {
...
    void speak() {
        std::cout << "I'm a Dog" << std::endl;
    }
...
}

void func(Animal* animal) {
    animal->speak();
}

int main() {
    Animal* myAnimal = new Animal;
    Dog* myDog = new Dog;
    func(myAnimal); // I'm an animal
    func(myDog); // I'm an animal
}
```

{% hint style="warning" %}
对于没有`virtual` 关键字的函数, 使用静态绑定, 它会在编译期完成, 绑定对象的静态类型.

使用`virtual` 后, 函数变为动态绑定, 绑定对象的动态类型, 在运行时确定
{% endhint %}

```cpp
class Animal {
...
    virtual void speak() {
        std::cout << "I'm an animal" << std::endl;
    }
...
}

class Dog : public Animal {
...
    void speak() override {
        std::cout << "I'm a Dog" << std::endl;
    }
...
}

void func(Animal* animal) {
    animal->speak();
}

int main() {
    Animal* myAnimal = new Animal;
    Dog* myDog = new Dog;
    func(myAnimal); // I'm an animal
    func(myDog); // I'm a Dog
}
```



## Algorithms

* `#include<algorithms>` 来使用STL中实现的算法.
* 所有算法都是 **泛化的**, **模板化** 的函数



