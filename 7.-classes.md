---
description: 所有容器都是在STL中定义好的类
---

# 7. Classes

## Class

类是程序员自定义的类型, 对对象或数据类型的抽象.



结构体的问题:

* 所有数据默认是public的
* 所有成员需要显式初始化



类为用户提供了**public**的接口, 并将其与**private**的实现隔离

```cpp
// student.h
class Student {
    public:
    std::string getName();
    void setName(std::string name);
    int getAge();
    void setAge(int age);
    
    private:
    std::string name;
    std::string state;
    int age;
};
```

Public部分:

* Student对象的用户都可以直接访问这里的所有东西.
* 为访问private成员变量定义了接口.

Private部分:

* 通常存储所有成员变量.
* 用户无法直接访问或修改私有部分.

```cpp
// student.cpp
#include student.h

std::string Student::getName() {
    return name;
}

void Student::setName(std::string name) {
    this->name = name;
}

int Student::getAge() {
    return age;
}

void Student::setAge(int age) {
    if (age >= 0) {
        this->age = age;
    }
    else error("Age cannot be negative.");
}
```

* namespace\_name::name 是对 namespace\_name 中的某个接口的实现.
* 在实现中可以访问到 namespace\_name 的私有变量.
* this是一个指针, 指向调用这个方法的实例.

{% hint style="warning" %}
通常情况下, 我们会对不修改成员变量的函数使用const修饰符, 如下:

std::string Car::getMake() const { return make; };

这会防止函数内对成员变量所有修改行为.
{% endhint %}

### Constructors

* 定义了创建实例时如何初始化成员变量.
* 当你创建Student实例时自动被调用.

```cpp
// student.cpp
#include student.h

// 1.0
Student::Student() {
    age = 0;
    name = "";
    state = "";
}

// 2.0, 函数重载
Student::Student() {
    age = 0;
    name = "";
    state = "";
}
Student::Student(std::string name, int age, std::string state) {
    this->name = name;
    this->age = age;
    this->state = state;
}

// 3.0, 使用初始化列表
Student::Student() : name{""}, age{0}, state{""} {}
Student::Student(std::string name, int age, std::string state) :
    name{name}, age{age}, state{state} {}
```

```cpp
// main.cpp
#include student.h
int main() {
    Student sarah;
    sarah.setName("Sarah");
    sarah.setAge(21);
    sarah.setState("CA");
    std::cout << sarah.getName() << " is from " << sarah.getState() << std:: endl;
    
    Student haven("Haven", 21, "AR");
    std::cout << haven.getName() << " is from " << haven.getState() << std::endl;
}
```



### Array

* 数组是所有容器的基本组成.
* 不要在应用代码中使用数组, 向量是数组的STL接口.

```cpp
int *my_int_array = new int[10];

int one_ele = my_int_array[0];
```



### Memory Management

* 数组空间需要手动释放.
  * delete \[] my\_int\_array;



### Destructor

* 实例的删除通常由析构函数进行
* 定义: Class\_name::\~Class\_name()
* 不需要显式调用, 会在实例out of scope时自动被调用
* 在.h文件中声明, 在.cpp文件中实现

```cpp
// student.cpp
#include student.h
Student::~Student() {
    delete [] my_array;
}
```

