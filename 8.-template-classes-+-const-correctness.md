---
description: How do we make our classes general? How do we make them safe?
---

# 8. Template Classes + Const Correctness

## Template Classes

软件工程的基本定理: Any problem can be solved by adding enough layers of indirection.任何问题都可以通过添加足够多的间接层来解决。

模板类: 对多种类型进行参数化的类. 这个类由general types的成员变量组成



### 我们用过的Template Classes

* Vectors
  * vector\<int> numVec; vector\<string> strVec;
* Maps
  * map\<int, string> int2Str; map\<int, int> int2Int;
* Sets
  * set\<int> someNums; set\<Student> someStudents;



### Writing a template: Syntax

```cpp
// Example: Structs
template<typename First, typename Secone> struct Mypair {
    First first;
    Second second;
};
```

```cpp
// mypair.h
template<typename First, typename Second> class Mypair {
    public:
        First getFirst();
        Second getSecond();
        
        void setFirst(First f);
        void setSecond(Second f);
    private:
        First first;
        Second second;
};
```

{% hint style="info" %}
使用泛型类名作为占位符!
{% endhint %}

```cpp
// mypair.cpp
#include "mypair.h"

template<typename First, typename Second> // 必须显式声明模板参数!
First MyPair<First, Second>::getFirst() { // 注意namespace不只是MyPair
    return first;
}

template<typename First, typename Second>
First MyPair<First, Second>::getSecond() {
    return second;
}
```

{% hint style="danger" %}
编译器在编译模板定义本身时(比如你写了一个 template \<typename T> void myFunction(T x))，它并不会生成任何机器代码。它只是把这个“蓝图”记在心里。只有当它在代码中看到你实际使用了这个模板(比如 myFunction(5) 或 myFunction\<std::string>(str)), 它才会根据这个蓝图和具体的类型(int 或 std::string)来生成对应的函数代码。
{% endhint %}

* 传统方式: 对于普通的非模板函数/类, 我们通常这样做:
  * 头文件(.h/.hpp): 包含函数/类的声明
  * 源文件(.cpp): 包含函数/类的定义
  * 在需要使用这个函数的其他文件中, 我们#include “something.h”, 链接器会把所有.cpp文件生成的.o文件链接在一起, 找到完整定义
* 但对于模板, 如果采取这种方式会出现问题:
* `my_template.h`: `template <typename T> void myFunction(T x);` // 只有声明
* `my_template.cpp`: `template <typename T> void myFunction(T x) { /*...实现...*/ }` // 定义在这里
* `main.cpp`: `#include “my_template.h”` 然后 `myFunction(5);` // 在这里实例化&#x20;

编译 `my_template.cpp` 时，编译器看到了模板的完整定义，但因为没有实例化（没人调用 `myFunction` with a specific type），所以它**不会生成任何代码**。\
编译 `main.cpp` 时，编译器看到了 `myFunction(5)`，它想实例化 `myFunction<int>`。但它**找不到函数定义**（定义在另一个 `my_template.cpp` 文件里，而那个文件已经编译完了，且是空的）。结果就是**链接错误（Linker Error）**，提示“未定义的外部符号”。



解决方法:

* 将完整定义写在.h文件中
* 或者, 在.h文件末尾#include对应实现的.tpp文件

### Member Types

* 有时候, 我们需要一个依赖于我们模板类型的类型名称.
* 比如iterators

```cpp
std::vector<int> a = {1, 2};
std::vector<int>::iterator it = a.begin();
```

* iterator 是vector的一个成员类型/嵌套类型/member type

#### Syntax

```cpp
// vector.h
template<typename T> class vector {
    public:
    using iterator = T*;
    
    iterator begin();
}
```

```cpp
// vector.cpp
template<typename T>
typename vector<T>::iterator vector<T>::begin() {...}
```

#### 1. 模板声明 (`template <typename T>`)

* **作用**：告诉编译器接下来的定义是一个模板，`T` 是一个类型参数。
* **为什么需要**：因为 `vector` 是一个类模板，它的成员函数也必然是函数模板。这个声明确保函数定义与类模板使用相同的模板参数。

#### 2. 返回类型 (`typename vector<T>::iterator`)

这是最复杂也是最关键的部分。

* **`vector<T>::iterator`**：这表示我们要使用 `vector<T>` 这个类内部定义的 `iterator` 类型。
* **关键的 `typename`**：这个关键字在这里**必须**使用。

**为什么需要 `typename`？**

因为对于编译器来说，`vector<T>` 是一个**依赖类型**——它的定义依赖于模板参数 `T`。在编译器实例化这个模板（比如用 `int` 替换 `T`）_之前_，它无法确定 `vector<T>::iterator` 到底是什么。

它可能是一个类型（比如 `using iterator = T*;`），也可能是一个静态成员变量（比如 `static int iterator;`）。编译器默认会假设它是一个**值（变量）**，而不是一个**类型**。

`typename` 关键字的作用就是**明确地告诉编译器**：”`vector<T>::iterator` 是一个类型，而不是一个值“。

**如果没有 `typename`，编译器会报错**，因为它会试图将 `iterator` 解释为一个变量名，然后发现它无法作为函数的返回类型。



#### Aside: Type Aliases

* 在应用代码中可以使用 `using type_name = type`&#x20;
* 在类中定义时, 产生一个嵌套类型, 如`vector::iterator`   &#x20;
* 在应用代码(如main.cpp)中使用时, 会在当前scope中创建type的别名, 直到跳出当前scope



#### summary

* 使用嵌套类型, 保证用户有对重要类型的标准化的访问方法
* 嵌套类型, 需要给出namespace`vector<T>::iterator`&#x20;
* 在声明之后, 就可以直接使用这个别名
* 声明时使用**typename**限制, 原因见上
