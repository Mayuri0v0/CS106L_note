---
description: A fancy way to say "how can we avoid making unnecessary copies of resources?"
---

# 13. Move Semantics

## L values vs r values

左值

* 左值**可以**在赋值号(=)的左边出现
* `x` 是一个左值
  * `int x = 3;`&#x20;
  * `int y = x;`&#x20;
* 左值有名字
* l-values are **not temporary.**



右值

* 右值**只能**在赋值号(=)的右边出现
* `3` 是一个右值
  * `int x = 3;`
  * `int y = x;`&#x20;
* 右值没有名字
* r-values are **temporary**.



{% hint style="success" %}
**左值**存活到脱离作用域为止.

**右值**存活到语句结束.
{% endhint %}



* `num2 = make_me_a_vec(23456)` 立即创建了一个对象, 进行复制, 然后摧毁了这个对象, 这是非常浪费的. 我们为什么不直接令右侧返回一个引用呢?



只有左值才能取引用, 但是我们有:

```cpp
 template <typename T>
 vector<T>& vector<T>::operator=(const vector<T>& other) {...}
  
 int main() {
 vector<int> vec;
 vec = make_me_a_vec(123); //make_me_a_vec(123) is an r-value
 }
```

我们分明为赋值符传入了一个右值, 这是因为右值可以绑定到 `const &` 上.



## r-value reference(&&)

```cpp
int main() {
    int x = 1;
    change(x); //this will call version 2
    change(7); //this will call version 1
}

void change(int&& num){...} //version 1 takes r-values
void change(int& num){...}  //version 2 takes l-values
//num is a reference to int
```



**Copy assignment**

```cpp
vector<T>& operator=(const vector<T>& other) 
{ 
    if (&other == this) 
        return *this; 
    _size = other._size; 
    _capacity = other._capacity; 
    
    //must copy entire array
    delete[] _elems; 
    _elems = new T[other._capacity]; 
    std::copy(other._elems, other._elems + other._size, _elems); 
    return *this; 
}
```



**Move assignment**

```cpp
vector<T>& operator=(vector<T>&& other)
{ 
    if (&other == this)
        return *this; 
    _size = other._size; 
    _capacity = other._capacity; 
    
    //we can steal the array
    delete[] _elems; 
    _elems = other._elems
    return *this; 
}
```

{% hint style="success" %}
编译器会根据RHS是左值还是右值自行选择调用哪个函数.
{% endhint %}



### std::move

* `std::move(x)` 除了把`x` 转换为右值以外**不会做任何事**.
* 这会强迫编译器选择`&&` 版本的函数.

我们由此可以构造一个更好的移动赋值函数:

```cpp
vector<T>& operator=(vector<T>&& other)
{ 
    if (&other == this)
        return *this; 
    _size = std::move(other._size); 
    _capacity = std::move(other._capacity); 
    
    //we can steal the array
    delete[] _elems; 
    _elems = std::move(other._elems);
    return *this; 
}
```



我们还应该在什么地方使用 `std::move` ?

{% hint style="success" %}
经验法则:

在类的成员函数中, 只要接受 `const&` 参数并在函数中将其赋值给其他内容的地方
{% endhint %}

{% hint style="danger" %}
**绝对不要**在类定义之外使用 `std::move` , **绝对不要**在应用代码中使用它.
{% endhint %}

