---
description: Special operations within your classes!
---

# 12. Special Member Functions

## Overview

一共有 **6** 个特殊成员函数, 这些函数在没有显式定义时会自动生成

* 默认构造函数
  * 无参数, 创建一个新对象时调用
* 析构函数
  * 当一个对象脱离作用域时自动调用
* 拷贝构造函数
  * 创建一个对象的副本时调用(默认浅拷贝)
* 拷贝赋值操作符
  * 执行对象间的`=` 时自动调用
* 移动构造函数
  * 使用右值(即将被销毁)初始化同类型对象时调用
  * 使用`std::move` 时调用
* 移动赋值操作符
  *

```cpp
class Widget {
    public:
        Widget();                            // default constructor
        Widget(const Widget& w);             // copy constructor
        Widget& operator = (const Widget& w);// copy assignment operator
        ~Widget();                           // destructor
        Widget(Widget&& rhs);                // move constructor
        Widget& operator = (Widget&& rhs);   // move assignment operator
```



## Copy and copy assignment

在默认情况下, 对象的复制是浅拷贝, 如果想要进行深拷贝, 需要自行Override函数.



## Default and delete

### delete

我们可以删除特殊成员函数:

```cpp
PasswordManager(const PasswordManager& rhs) = delete;
PasswordManager& operator = (const PasswordManager& rhs) = delete;
```

此时复制操作会产生编译错误.



### default

```cpp
PasswordManager();
PasswordManager(const PasswordManager& pm) = default; // 默认浅拷贝
```

`default` 关键字声明一个默认的函数



### The Rule of 0

{% hint style="danger" %}
如果默认特殊成员函数正常工作, **不要自行定义**!
{% endhint %}

只在默认函数行为错误时重新定义:

* 比如成员包含指针, 需要深拷贝



### The Rule of 5

{% hint style="danger" %}
当你需要定义除了构造函数外的任意一个函数时, **同时定义五个**!

或者用 `= default` 或 `= delete` 明确说明意图
{% endhint %}

* 当你需要定义其中一个, 说明你需要手动管理某些资源
* 这意味着, 复制, 析构时, 我们都需要手动管理它们



## Move and move assignment

拷贝函数将会复制所有的成员变量, 速度很慢.

* 移动构造函数与移动赋值操作符会移动所有的成员变量.
* 如果你在类中显式地定义了移动赋值运算符 (`operator=`)，编译器将不会为你自动生成移动构造函数；反之，如果你显式定义了移动构造函数，编译器也不会自动生成移动赋值运算符。\


为了保持向后兼容性和安全性，C++ 标准为这些函数的自动生成设定了一套复杂的规则。其中一条关键规则是：

**“三大法则” (Rule of Three) 进化成了“五大法则” (Rule of Five)：**

如果一个类**显式定义**了以下任何一个特殊成员函数，意味着该类需要进行某种手动的资源管理（例如，在堆上分配内存、持有文件句柄等）：

* 析构函数
* 拷贝构造函数
* 拷贝赋值运算符

那么编译器通常**不会自动生成**移动构造函数和移动赋值运算符（它们会被隐式地定义为 `= delete`）。这是为了安全起见，防止编译器生成可能错误的移动操作，导致资源双重释放等问题。

**而这条规则的延伸就是：**

当你**显式定义**了**移动赋值运算符**时，你是在告诉编译器：“我知道如何以移动的方式处理这个对象的赋值，让我自己来。” 编译器会据此认为：

1. 你的类很可能有复杂的资源管理需求（否则你会用默认的）。
2. 既然移动赋值你都自己定义了，移动构造很可能也需要特殊的处理。
3. 为了安全起见，编译器决定**不自动生成移动构造函数**，防止你只处理了一半的移动逻辑而导致问题。

**反之亦然**。如果你定义了**移动构造函数**，编译器也会认为“这个类的移动操作很特殊”，从而**不自动生成移动赋值运算符**。



### Caveats

当你声明任意的:

* 拷贝操作
* 移动操作
* 析构函数

都会使得默认的移动构造函数与操作符失效, 需要自行定义.

如果你想要显式的使用默认定义, 使用`default`
