---
description: 如何顺序访问容器内的元素?如何引用代码中已有的数据?
---

# 6. Iterators and Pointers

## Iterators

* 如果我们想打印vector内的所有内容呢?
* 或者循环直到找到set中的某个特定元素

很难写出循环的条件, 这时需要引入iterator



所有容器都实现了iterator来执行这个功能

* iterator让你可以程序化的访问容器内的所有元素
* 一个iterator自带顺序, 它直到自己接下来该访问哪个元素
* 每一个容器自带的iterator行为不同



* 所有iterator都实现了一些相同的功能
  * 初始化
    * iter = s.begin();
  * 递增
    * ++iter;
  * 解引用
    * \*iter;
  * 比较--
    * iter != s.end();
  * 复制
    * new\_iter = iter;



### Forward iterator

单向迭代器是标准容器所带功能最少的iterator.

* **Input** iterator 可以在等号右边出现.
  * auto elem = \*iter;
* **Output** iterator 可以在等号左侧出现;
  * \*elem = value;



### Bidirectional iterator

双向迭代器可以向前或向后.

* \--iter;
* 与单向迭代器相同的功能



### Random-access iterator

随机存储迭代器可以不必顺序遍历而直接找到某个元素.

* iter += 5;



| Container      | Type of Iterator |
| -------------- | ---------------- |
| Vector         | Random-Access    |
| Deque          | Random-Access    |
| List           | Bidirectional    |
| Map            | Bidirectional    |
| Set            | Bidirectional    |
| Stack          | No Iterator      |
| Queue          | No Iterator      |
| Priority Queue | No Iterator      |

* 创建自己的容器时, 需要创建它的迭代器.
* 你可以访问stack和queue的每个元素, 但是在过程中你不得不改变容器
* Iteration with iterators is **const**



```cpp
for (auto iter=set.begin(); iter != set.end(); ++iter) {
```

这样我们就可以访问每个元素了!

想要元素本身时, 解引用即可(\*iter)

```cpp
const auto& elem = *iter;
```



对于map,可以在解引用时直接结构化绑定, 更有效率.

```cpp
std::map<int, int> test{{1, 6}, {2, 8}, {0, 3}, {3, 9}};
for (auto iter = map.begin(); iter != map.end(); iter++) {
    const auto& [key, value] = *iter;
}
```

这是一个典型的C++对容器的循环.



## Pointer

迭代器是一种特殊的指针.

* 迭代器指向容器中特定的元素.
* 指针指向任意的对象.



```cpp
int val = 18;
int* ptr = &val;
// &: 取地址, *: 解引用
```



### 如果指向的对象有成员变量呢?

```cpp
*ptr.var
ptr->var
// 两者作用完全相同
```

